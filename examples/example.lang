import "users.lang"

let SHORT_DATE_FORMAT = "%Y-%m-%d"

entity Profile {
  name:      dict("full_names"),
  addresses: dict("full_address")<0..3>,
  gender:    dict("genders"),
  dob:       date(1970-01-01, 1999-12-31, SHORT_DATE_FORMAT),
  email_confirmed: bool,
}

let bestSelling = "Skinny"

let jeanStyles = ["Classic", "Fitted", "Relaxed", bestSelling]

entity CatalogItem {
  title: dict("words"),
  style: enum(jeanStyles),
  sku:   string(10),
  price: decimal(1.0, 30.00)
}

let Products = generate(10, CatalogItem)

let stateTax = 0.1
let federalTax = 0.2

entity CartItem {
  product: enum(Products),
  quantity: integer(1, 3),
  tax: stateTax + federalTax
}

entity Cart {
  items: CartItem<0..10>,
  total: decimal # TODO: this should be a calculated item based on CartItems price x quantity + tax
}

# Currently it would be difficult to implement a social network,
# i.e. a customer's "friends". Nesting a customer within a customer as
# a "friend" field seems somewhat unnatural, not to mention would blow
# the stack with infinite nesting unless the nested Customer had their
# friend set to null via override. Definitely a shortcoming in the language.
entity Customer << User {
  last_login:     date(2010-01-01, NOW), # UNIX_EPOCH and NOW are predefined variables
  profile:        Profile,
  cart:           Cart
}

# Generate statements
# TODO: might be awkward to control over specific test user's carts with the current language capabilities
# -- should explore more fine-grained relationship handling & get feedback on this
generate (2, Admin)
generate (2, Customer << {cart: null}) # new users don't have a cart yet
generate (10, Customer)
