package interpreter

import (
	"fmt"
	. "github.com/ThoughtWorksStudios/bobcat/common"
	"github.com/ThoughtWorksStudios/bobcat/dictionary"
	"github.com/ThoughtWorksStudios/bobcat/generator"
	"github.com/lazybeaver/xorshift"
	"github.com/rs/xid"
	"math"
	"math/rand"
	"time"
)

var SRC = rand.NewSource(time.Now().UnixNano())

var LETTER_INDEX_BITS uint = uint(math.Ceil(math.Log2(float64(len(ALLOWED_CHARACTERS))))) // number of bits to represent ALLOWED_CHARACTERS
var LETTER_BIT_MASK int64 = 1<<LETTER_INDEX_BITS - 1                                      // All 1-bits, as many as LETTER_INDEX_BITS
var LETTERS_PER_INT63 uint = 63 / LETTER_INDEX_BITS                                       // # of letter indices fitting in 63 bits as generated by SRC.Int63

func defaultArgs(builtinType string) ([]interface{}, error) {
	switch builtinType {
	case STRING_TYPE:
		return []interface{}{int64(5)}, nil
	case INT_TYPE:
		return []interface{}{int64(1), int64(10)}, nil
	case FLOAT_TYPE:
		return []interface{}{float64(1), float64(10)}, nil
	case DATE_TYPE:
		return []interface{}{UNIX_EPOCH, NOW, ""}, nil
	case SERIAL_TYPE:
		return []interface{}{int64(0)}, nil
	default:
		return nil, fmt.Errorf("Field of type `%s` requires arguments", builtinType)
	}
}

func NewBuiltin(builtinName string) (Callable, error) {
	switch builtinName {
	case STRING_TYPE:
		return &StringBuiltin{}, nil
	case INT_TYPE:
		return &IntegerBuiltin{}, nil
	case FLOAT_TYPE:
		return &FloatBuiltin{}, nil
	case DATE_TYPE:
		return &DateBuiltin{}, nil
	case DICT_TYPE:
		return &DictBuiltin{}, nil
	case BOOL_TYPE:
		return &BoolBuiltin{}, nil
	case ENUM_TYPE:
		return &EnumBuiltin{}, nil
	case SERIAL_TYPE:
		return &SerialBuiltin{}, nil
	case UID_TYPE:
		return &UidBuiltin{}, nil
	case UNIQUE_INT_TYPE:
		return &UniqueIntBuiltin{
			source: xorshift.NewXorShift128Plus(uint64(time.Now().Nanosecond())),
		}, nil
	default:
		return nil, fmt.Errorf("Unknown builtin %q", builtinName)
	}
}

type UniqueIntBuiltin struct {
	source xorshift.XorShift
}

func (f *UniqueIntBuiltin) Name() string {
	return UNIQUE_INT_TYPE
}

func (f *UniqueIntBuiltin) Call(args ...interface{}) (interface{}, error) {
	if len(args) != 0 {
		return nil, fmt.Errorf("%s() takes no arguments", f.Name())
	}
	return f.source.Next(), nil
}

type BoolBuiltin struct{}

func (f *BoolBuiltin) Name() string {
	return BOOL_TYPE
}

func (f *BoolBuiltin) Call(args ...interface{}) (interface{}, error) {
	if len(args) != 0 {
		return nil, fmt.Errorf("%s() takes no arguments", f.Name())
	}
	return 49 < rand.Intn(100), nil
}

type UidBuiltin struct{}

func (f *UidBuiltin) Name() string {
	return UID_TYPE
}

func (f *UidBuiltin) Call(args ...interface{}) (interface{}, error) {
	if len(args) != 0 {
		return nil, fmt.Errorf("%s() takes no arguments", f.Name())
	}
	return xid.New().String(), nil
}

type SerialBuiltin struct {
	current uint64
}

func (f *SerialBuiltin) Name() string {
	return SERIAL_TYPE
}

func (f *SerialBuiltin) parseArgs(args []interface{}) ([]interface{}, error) {
	var err error
	if 0 == len(args) {
		if args, err = defaultArgs(f.Name()); err != nil {
			return nil, err
		}
	}

	if len(args) != 1 {
		return nil, fmt.Errorf("%s() takes at most 1 argument", f.Name())
	}

	if current, ok := args[0].(int64); ok && current > -1 {
		return []interface{}{uint64(current)}, nil
	} else {
		return nil, fmt.Errorf("%s() offset must be a non-negative integer", f.Name())
	}
}

func (f *SerialBuiltin) Call(args ...interface{}) (interface{}, error) {
	args, err := f.parseArgs(args)
	if err != nil {
		return nil, err
	}

	start := args[0].(uint64)

	result := f.current + start
	f.current++
	return result, nil
}

type StringBuiltin struct{}

func (f *StringBuiltin) Name() string {
	return STRING_TYPE
}

const ALLOWED_CHARACTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@"

func (f *StringBuiltin) parseArgs(args []interface{}) ([]interface{}, error) {
	var err error
	if 0 == len(args) {
		if args, err = defaultArgs(f.Name()); err != nil {
			return nil, err
		}
	}

	if n, ok := args[0].(int64); !ok || len(args) > 1 {
		return nil, fmt.Errorf("%s() takes exactly 1 integer argument", f.Name())
	} else {
		if n < 0 {
			return nil, fmt.Errorf("string length cannot be negative")
		}
	}
	return args, nil
}

func (f *StringBuiltin) Call(args ...interface{}) (interface{}, error) {
	var n int64

	if args, err := f.parseArgs(args); err == nil {
		n, _ = args[0].(int64)
	} else {
		return nil, err
	}

	b := make([]byte, n)

	for i, cache, remain := n-1, SRC.Int63(), LETTERS_PER_INT63; i >= int64(0); {
		if remain == 0 {
			cache, remain = SRC.Int63(), LETTERS_PER_INT63
		}
		if idx := int(cache & LETTER_BIT_MASK); idx < len(ALLOWED_CHARACTERS) {
			b[i] = ALLOWED_CHARACTERS[idx]
			i--
		}
		cache >>= LETTER_INDEX_BITS
		remain--
	}

	return string(b), nil
}

type IntegerBuiltin struct{}

func (f *IntegerBuiltin) Name() string {
	return INT_TYPE
}

func (f *IntegerBuiltin) parseArgs(args []interface{}) ([]interface{}, error) {
	var err error
	if 0 == len(args) {
		if args, err = defaultArgs(f.Name()); err != nil {
			return nil, err
		}
	}

	if 2 != len(args) {
		return nil, fmt.Errorf("Usage: %s(min, max)", f.Name())
	}

	min, ok1 := args[0].(int64)
	max, ok2 := args[1].(int64)

	if !ok1 || !ok2 {
		return nil, fmt.Errorf("%s() `min` and `max` boundaries must be integers", f.Name())
	}

	if max < min {
		return nil, fmt.Errorf("%s() `max` cannot be less than `min`", f.Name())
	}

	return args, nil
}

func (f *IntegerBuiltin) Call(args ...interface{}) (interface{}, error) {
	var err error
	if args, err = f.parseArgs(args); err != nil {
		return nil, err
	}

	min, max := args[0].(int64), args[1].(int64)
	return min + rand.Int63n(max-min+1), nil
}

type FloatBuiltin struct{}

func (f *FloatBuiltin) asFloat(value interface{}) (float64, error) {
	switch value.(type) {
	case int64:
		return float64(value.(int64)), nil
	case float64:
		return value.(float64), nil
	default:
		return 0, fmt.Errorf("%s() `min` and `max` boundaries must be numeric", f.Name())
	}
}

func (f *FloatBuiltin) parseArgs(args []interface{}) ([]interface{}, error) {
	var err error
	if 0 == len(args) {
		if args, err = defaultArgs(f.Name()); err != nil {
			return nil, err
		}
	}

	if 2 != len(args) {
		return nil, fmt.Errorf("Usage: %s(min, max)", f.Name())
	}

	var min float64
	var max float64

	if min, err = f.asFloat(args[0]); err != nil {
		return nil, err
	}
	args[0] = min

	if max, err = f.asFloat(args[1]); err != nil {
		return nil, err
	}
	args[1] = max

	if max < min {
		return nil, fmt.Errorf("%s() `max` cannot be less than `min`", f.Name())
	}

	return args, nil
}

func (f *FloatBuiltin) Name() string {
	return FLOAT_TYPE
}

func (f *FloatBuiltin) Call(args ...interface{}) (interface{}, error) {
	var err error
	if args, err = f.parseArgs(args); err != nil {
		return nil, err
	}

	min, max := args[0].(float64), args[1].(float64)

	return rand.Float64()*(max-min) + min, nil
}

type DateBuiltin struct {
	min    time.Time
	max    time.Time
	format string
}

func (f *DateBuiltin) Name() string {
	return DATE_TYPE
}

func (f *DateBuiltin) ValidBounds() bool {
	return f.min.Before(f.max)
}

func (f *DateBuiltin) parseArgs(args []interface{}) ([]interface{}, error) {
	var err error
	if 0 == len(args) {
		if args, err = defaultArgs(f.Name()); err != nil {
			return nil, err
		}
	}

	num := len(args)
	if num < 2 || num > 3 {
		return nil, fmt.Errorf("Usage: %s(from_date, to_date [, date_format])", f.Name())
	}

	min, ok1 := args[0].(time.Time)
	max, ok2 := args[1].(time.Time)

	if !ok1 || !ok2 {
		return nil, fmt.Errorf("%s() `from` and `to` boundaries must be dates", f.Name())
	}

	if max.Before(min) {
		return nil, fmt.Errorf("%s() `to` date cannot be earlier than `from` date", f.Name())
	}

	if 3 == num {
		if _, ok := args[2].(string); !ok {
			return nil, fmt.Errorf("%s() `date_format` must be a string", f.Name())
		}
	} else {
		args = append(args, "")
	}

	return args, nil
}

func (f *DateBuiltin) Call(args ...interface{}) (interface{}, error) {
	var err error
	if args, err = f.parseArgs(args); err != nil {
		return nil, err
	}

	min, max, format := args[0].(time.Time).Unix(), args[1].(time.Time).Unix(), args[2].(string)

	delta := max - min
	sec := rand.Int63n(delta) + min

	return &generator.TimeWithFormat{Time: time.Unix(sec, 0), Format: format}, nil
}

type DictBuiltin struct{}

var CustomDictPath = ""

func (f *DictBuiltin) Name() string {
	return DICT_TYPE
}

func (f *DictBuiltin) Call(args ...interface{}) (interface{}, error) {
	if len(args) != 1 {
		return nil, fmt.Errorf("Usage: %s(category_name)", f.Name())
	}

	category, ok := args[0].(string)

	if !ok || "" == category {
		return nil, fmt.Errorf("%s() `category_name` must be a non-empty string", f.Name())
	}

	dictionary.SetCustomDataLocation(CustomDictPath)
	return dictionary.ValueFromDictionary(category), nil
}

type EnumBuiltin struct{}

func (f *EnumBuiltin) Name() string {
	return ENUM_TYPE
}

func (f *EnumBuiltin) Call(args ...interface{}) (interface{}, error) {
	if len(args) != 1 {
		return nil, fmt.Errorf("Usage: %s(collection)", f.Name())
	}

	values, ok := args[0].([]interface{})

	if !ok {
		return nil, fmt.Errorf("%s() `collection` must be a collection", f.Name())
	}

	if size := len(values); size == 0 {
		return nil, nil
	} else {
		return values[rand.Int63n(int64(size))], nil
	}
}
