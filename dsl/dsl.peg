{
  package dsl

  import "fmt"
  import "regexp"
  import "strings"

  // recursively finds Node values and flattens the resulting slice
  func searchNodes(v interface{}) NodeSet {
    if nil == v { return NodeSet{} }

    vars := v.([]interface{})
    nodes := make(NodeSet, 0)

    for _, val := range vars {
      n, isNode := val.(Node)

      if isNode {
        nodes = append(nodes, n)
      } else {
        more, isSlice := val.([]interface{})
        if isSlice {
          nodes = append(nodes, searchNodes(more)...)
        }
      }

    }

    return nodes
  }

  // convenience function to join a single Node with a
  // Node slice representing 0 or more Node values; Often
  // used to handle arguments, filtering out whitespace and
  // delimiter matches
  func delimitedNodeSlice(first, rest interface{}) NodeSet {
    res := make(NodeSet, 1)
    res[0] = first.(Node)

    if nil != rest {
      res = append(res, searchNodes(rest)...)
    }

    return res
  }

  // a convenience function to nil-check, returning an empty
  // Node slice in place of nil
  func defaultToEmptySlice(nodes interface{}) NodeSet {
    if nil == nodes {
      return NodeSet{}
    }

    return nodes.(NodeSet)
  }

  // converts the output of successive character-class matches
  // into a string
  func charGroupAsString(v interface{}) string {
    c := v.([]interface{})
    s := make([]byte, len(c))
    i := 0

    for _, val := range c {
      s[i] = val.([]byte)[0]
      i = i + 1
    }

    return string(s)
  }

  /**
   * Parses date and date + timestamp in ISO-8601 variations just like
   * JavaScript. Specifically:
   *
   * YYYY-MM-DD
   * YYYY-mm-ddTHH:MM:SS
   * YYYY-mm-ddTHH:MM:SSZ
   * YYYY-mm-ddTHH:MM:SS-0000
   * YYYY-mm-ddTHH:MM:SS-00:00
   */
  func ParseDateLikeJS(tstamp string) (time.Time, error) {
    // you'll just have to take my word on this
    re := regexp.MustCompile("^([0-9]{4}-[0-9]{2}-[0-9]{2})(?:(T[0-9]{2}:[0-9]{2}:[0-9]{2})(Z|(?:[+-][0-9]{2}:?[0-9]{2}))?)?$")

    format := "2006-01-02" // default to parsing only the date

    m := re.FindStringSubmatch(tstamp)

    if m == nil {
      return time.Time{}, fmt.Errorf("Not a parsable timestamp: %s", tstamp)
    }

    parts := []string {m[1], m[2], strings.Replace(strings.Replace(m[3], ":", "", -1), "Z", "", -1)}

    if m[2] != "" {
      format = format + "T15:04:05"
    }

    if m[3] != "" && m[3] != "Z" {
      format = format + "-0700"
    }

    return time.Parse(format, strings.Join(parts, ""))
  }
}

Script = prog:Statement* EOF {
  return rootNode(c, prog)
}

Statement = statement:(EntityDef / EntityGen) {
  return statement, nil
}

EntityGen = _ "generate" _ name:Identifier _ args:Arguments _ {
  return genNode(c, name, args)
}

EntityDef = _ "def" _ name:Identifier _ '{' _ body:FieldSet? _ '}' _ {
  return entityNode(c, name, body)
}

FieldSet = first:FieldDecl rest:(_ ',' _ FieldDecl)* (_ ',')? {
  return delimitedNodeSlice(first, rest), nil
}

FieldDecl = StaticDecl / SymbolicDecl

StaticDecl = name:Identifier _ fieldValue:Literal _ {
  return staticFieldNode(c, name, fieldValue)
}

SymbolicDecl = name:Identifier _ fieldType:Builtin _ args:Arguments? _ {
  return dynamicFieldNode(c, name, fieldType, args)
}

Arguments = '(' _ first:SingleArgument rest:(_ ',' _ SingleArgument)* _ ')' {
  return delimitedNodeSlice(first, rest), nil
}

Literal = DateTimeLiteral / NumberLiteral / BoolLiteral / StringLiteral / NullLiteral

SingleArgument = Literal / Identifier

Identifier = !ReservedWord [a-z_]i[a-z0-9_]i* {
  return idNode(c)
}

Builtin "built-in types" = FieldTypes {
  return builtinNode(c)
}

DateTimeLiteral = date:(DIGIT DIGIT DIGIT DIGIT '-' DIGIT DIGIT '-' DIGIT DIGIT) localTime:LocalTimePart? {
  return dateLiteralNode(c, date, localTime)
}

LocalTimePart = ts:('T'i DIGIT DIGIT ':' DIGIT DIGIT ':' DIGIT DIGIT) zone:ZonePart? {
  ts = strings.ToUpper(charGroupAsString(ts))

  if zone == nil {
    return []string{ts.(string)}, nil
  } else {
    return []string {ts.(string), zone.(string)}, nil
  }
}

ZonePart = 'Z'i { return 'Z', nil } / [+-] DIGIT DIGIT ':'? DIGIT DIGIT { return strings.Replace(string(c.text), ":", "", -1), nil }

NumberLiteral = '-'? INT ('.' DIGIT+)? {
  if s := string(c.text); strings.ContainsAny(s, ".") {
    return floatLiteralNode(c, s)
  } else {
    return intLiteralNode(c, s)
  }
}

BoolLiteral = BoolToken {
  return boolLiteralNode(c)
}

NullLiteral = NullToken {
  return nullLiteralNode(c)
}

StringLiteral = '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
  return strLiteralNode(c)
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

UnicodeEscape = 'u' HEXDIG HEXDIG HEXDIG HEXDIG

INT = '0' / NON_ZERO DIGIT*

NON_ZERO = [1-9]

DIGIT = [0-9]

HEXDIG = [0-9a-f]i

ReservedWord = Keyword / FieldTypes / NullToken / BoolToken

Keyword = "def" / "generate"

FieldTypes = "integer" / "decimal" / "string" / "date" / "dict"

NullToken = "null"

BoolToken = "true" / "false"

_ "whitespace" = [ \t\r\n]*

EOF = !.
