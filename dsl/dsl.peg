{
  package dsl

  import (
    "regexp"
    "strconv"
    . "github.com/ThoughtWorksStudios/bobcat/common"
  )

  func invalid(format string, tokens ...interface{}) error {
    return fmt.Errorf(format, tokens...)
  }
}

Script = prog:(Statement / Comment)* EOF {
  Msg("rule Script")

  return rootNode(c, prog), nil
} / !Statement .* EOF { return nil, invalid("Don't know how to evaluate %q", string(c.text)) }

Statement = _ statement:(ImportStatement / Expr / Assignment) _ {
  Msg("rule Statement")

  return statement, nil
}

Value = Literal / Identifier

Expr = GenerateExpr / EntityExpr / Literal

ImportStatement = "import" _ path:StringLiteral {
  Msg("rule ImportStatement")

  pathNode, _ := path.(*Node)

  if fspath := strings.TrimSpace(pathNode.ValStr()); fspath == "" {
    return nil, invalid("import statement requires a resolvable path")
  } else {
    return importNode(c, fspath), nil
  }
} / FailOnBadImport

GenerateExpr = "generate" _ '(' _ count:Value _ ',' _ entity:EntityRef _ ')' {
  Msg("rule GenerateExpr")

  if count.(*Node).Kind != "literal-int" {
    return nil, invalid("`generate` takes a non-zero integer count as its first argument")
  }

  return genNode(c, entity, NodeSet{count.(*Node)}), nil
} / FailOnUnterminatedGeneratorArguments / FailOnMissingGenerateArguments

Assignment = FailOnMissingRightHandAssignment / leftHand:Identifier _ ASSIGN_OP _ rightHand:(Expr / Identifier) {
  if leftHand == nil {
    return nil, nil
  }

  Msg("rule Assignment left: %v to right: %v", leftHand, rightHand)

  return assignNode(c, leftHand, rightHand), nil
}

EntityRef = Assignment / EntityExpr / Identifier

EntityExpr "entity expression" = extends:Identifier? _ '{' _ body:FieldSet? _ '}' {
  Msg("rule EntityLiteral extends: %v, body: %v", extends, body)

  var parentIdentNode *Node
  var ok bool

  if nil != extends {
    if parentIdentNode, ok = extends.(*Node); !ok {
      return nil, fmt.Errorf("Entity cannot extend %T %v", extends, extends)
    }
  }

  return entityNode(c, parentIdentNode, body), nil
} / FailOnUnterminatedEntity

FieldSet "entity fields" = FailOnUndelimitedFields / first:FieldDecl rest:(_ ',' _ FieldDecl)* (_ ',')? {
  Msg("rule FieldSet first: %v, rest: %v", first, rest)

  if first == nil {
    return nil, nil
  }

  return delimitedNodeSlice(first, rest), nil
}

FieldDecl = StaticDecl / DynamicDecl / FailOnMissingFieldType

StaticDecl "field declaration" = name:Identifier _ fieldValue:Literal _ count:CountRange? _ {
  Msg("rule StaticDecl")

  if name == nil {
    return nil, nil
  }

  rng, _ := count.(*Node)
  return staticFieldNode(c, name, fieldValue, rng), nil
}

DynamicDecl "field declaration" = name:Identifier _ fieldType:(Builtin / EntityRef) _ args:Arguments? _ count:CountRange? _ {
  Msg("rule DynamicDecl name: %v => fieldType: %v with args %v", name, fieldType, args)

  if name == nil || fieldType == nil {
    return nil, nil
  }

  rng, _ := count.(*Node)
  return dynamicFieldNode(c, name, fieldType, args, rng), nil
}

CountRange = '<' _ countRange:(Range / NumberLiteral)? _ '>' { // TODO: accept Identifier
  Msg("rule CountRange")

  return countRange, nil
} / FailOnUnterminatedCountRange

Range = min:NumberLiteral ".." max:NumberLiteral {
  Msg("rule Range")

  lower, _ := min.(*Node)
  upper, _ := max.(*Node)

  if (lower.Kind != "literal-int" && lower.Kind != "identifier") || (upper.Kind != "literal-int" && upper.Kind != "identifier") {
    return nil, fmt.Errorf("Range boundaries must be integers")
  }

  return rangeNode(c, lower, upper), nil
}

Arguments = '(' _ body:ArgumentsBody? _ ')' {
  Msg("rule Arguments %v", body)

  return defaultToEmptySlice(body), nil
} / FailOnUnterminatedArguments

ArgumentsBody "arguments body" = FailOnUndelimitedArgs / first:Value rest:(_ ',' _ Value)* {
  Msg("rule ArgumentsBody")

  if first == nil {
    return nil, nil
  }

  return delimitedNodeSlice(first, rest), nil
}

Literal = CollectionLiteral / DateTimeLiteral / NumberLiteral / BoolLiteral / StringLiteral / NullLiteral

Identifier = !ReservedWord [a-z0-9_$]i+ {
  val := string(c.text)
  Msg("rule Identifier => %q", val)


  if strings.Contains(val, "$") {
    return nil, invalid("Illegal identifier %q; identifiers start with a letter or underscore, followed by zero or more letters, underscores, and numbers", val)
  }

  if m, e := regexp.MatchString(`^\d`, val); m || e != nil {
    return nil, invalid("Illegal identifier %q; identifiers start with a letter or underscore, followed by zero or more letters, underscores, and numbers", val)
  }

  return idNode(c, val), nil
} / FailOnIllegalIdentifier

Builtin "built-in types" = FieldTypes {
  Msg("rule Builtin => %q", string(c.text))

  return builtinNode(c, string(c.text)), nil
}

CollectionLiteral = "[" _ body:ArgumentsBody? _ "]" {
  Msg("rule CollectionLiteral")

  return collectionLiteralNode(c, body), nil
}

DateTimeLiteral = date:IsoDate localTime:LocalTimePart? {
  Msg("rule DateTimeLiteral")

  if dateTime, err := assembleTime(date, localTime); err == nil {
    return dateLiteralNode(c, dateTime), nil
  } else {
    return nil, err
  }
} / FailOnMissingDate

LocalTimePart = ts:TimePart zone:ZonePart? {
  Msg("rule LocalTimePart")

  if zone == nil {
    return []string{ts.(string)}, nil
  } else {
    return []string{ts.(string), zone.(string)}, nil
  }
}

IsoDate = DIGIT DIGIT DIGIT DIGIT '-' DIGIT DIGIT '-' DIGIT DIGIT { return string(c.text), nil}
TimePart = 'T'i DIGIT DIGIT ':' DIGIT DIGIT ':' DIGIT DIGIT { return strings.ToUpper(string(c.text)), nil }
ZonePart = 'Z'i { return "Z", nil } / [+-] DIGIT DIGIT ':'? DIGIT DIGIT { return strings.Replace(string(c.text), ":", "", -1), nil }

NumberLiteral = '-'? INT ('.' DIGIT+)? {
  Msg("rule NumberLiteral")

  if s := string(c.text); strings.ContainsAny(s, ".") {
    if val, er := strconv.ParseFloat(s, 64); er == nil {
      return floatLiteralNode(c, val), nil
    } else {
      return nil, er
    }
  } else {
    if val, er := strconv.ParseInt(s, 10, 64); er == nil {
      return intLiteralNode(c, val), nil
    } else {
      return nil, er
    }
  }
} / FailOnOctal

BoolLiteral = BoolToken {
  Msg("rule BoolLiteral")
  if val, er := strconv.ParseBool(string(c.text)); er == nil {
    return boolLiteralNode(c, val), nil
  } else {
    return nil, er
  }
}

NullLiteral = NullToken {
  Msg("rule NullLiteral")

  return nullLiteralNode(c), nil
}

StringLiteral = '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
  Msg("rule StringLiteral")
  if val, er := strconv.Unquote(string(c.text)); er == nil {
    return strLiteralNode(c, val), nil
  } else {
    return nil, er
  }
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

UnicodeEscape = 'u' HEXDIG HEXDIG HEXDIG HEXDIG

ASSIGN_OP = '='

INT = '0' / NON_ZERO DIGIT*

NON_ZERO = [1-9]

DIGIT = [0-9]

HEXDIG = [0-9a-f]i

ReservedWord = Keyword / FieldTypes / NullToken / BoolToken

Keyword = "import" / "generate"

FieldTypes = "integer" / "decimal" / "string" / "date" / "dict" / "bool" / "enum"

NullToken = "null"

BoolToken = "true" / "false"

/**
 *  88 88b 88 Yb    dP    db    88     88 8888b.      88""Yb 88   88 88     888888 .dP"Y8
 *  88 88Yb88  Yb  dP    dPYb   88     88  8I  Yb     88__dP 88   88 88     88__   `Ybo."
 *  88 88 Y88   YbdP    dP__Yb  88  .o 88  8I  dY     88"Yb  Y8   8P 88  .o 88""   o.`Y8b
 *  88 88  Y8    YP    dP""""Yb 88ood8 88 8888Y"      88  Yb `YbodP' 88ood8 888888 8bodP'
 */

FailOnBadImport "invalid import statment" = "import" _ [^ \t\r\n]* { return nil, invalid("import statement requires a path") }
FailOnOctal "octal numbers not supported" = "\\0" DIGIT+ { return Node{}, invalid("Octal sequences are not supported") }
FailOnUnterminatedEntity "unterminated entity" = _ Identifier? _ '{' _ FieldSet? _ EOF { return nil, invalid("Unterminated entity expression (missing closing curly brace") }
FailOnUndelimitedFields "missing field delimiter" = FieldDecl (_ "," _) (_ "," _)+ {return nil, invalid("Expected another field declaration")} / FieldDecl (_ FieldDecl)+ { return nil, invalid("Multiple field declarations must be delimited with a comma") }
FailOnUnterminatedCountRange "unterminated countRange" = '<' _ Range? _ ([^>] / EOF) { return nil, invalid("Unterminated countRange list (missing closing angled bracket)") }
FailOnUnterminatedArguments "unterminated arguments" = '(' _ ArgumentsBody? _ (!Value [^)] / EOF) { return nil, invalid("Unterminated argument list (missing closing parenthesis)") }
FailOnUndelimitedArgs "missing argument delimiter" = Value ((_ / _ [^,})] _) Value)+ { return nil, invalid("Multiple arguments must be delimited with a comma") }
FailOnIllegalIdentifier "illegal identifier" = ReservedWord {
  Msg("FailOnIllegalIdentifier => %q", string(c.text))

  return nil, invalid("Illegal identifier: %q is a reserved word", string(c.text))
}
FailOnMissingDate "timestamps must have date" = LocalTimePart { return Node{}, invalid("Must include ISO-8601 (YYYY-MM-DD) date as part of timestamp") }
FailOnMissingGenerateArguments = _ "generate" _ (EntityRef / '(' _ (EntityRef / Value) _ ')') _ { return nil, invalid("`generate` statement %q requires arguments `(count, entity)`", string(c.text)) }
FailOnUnterminatedGeneratorArguments = _ "generate" _ '(' _ ((EntityRef / Value) (_ ',' _ (EntityRef / Value))*)? _ [^)] _ { return nil, invalid("`generate` statement %q requires arguments `(count, entity)`", string(c.text)) }
FailOnMissingFieldType = Identifier { return nil, invalid("Missing field type for field declaration %q", string(c.text)) }
FailOnMissingRightHandAssignment = leftHand:Identifier _ ASSIGN_OP _ !Expr .* {
  Msg("rule FailOnMissingRightHandAssignment")

  if leftHand == nil {
    return nil, nil // bad identifier
  }
  return nil, invalid("Missing right-hand of assignment expression %q", string(c.text))
}

/**
 *  888888 88b 88 8888b.
 *  88__   88Yb88  8I  Yb
 *  88""   88 Y88  8I  dY
 *  888888 88  Y8 8888Y"
 */

Comment = '#' (!EOL .)* EOL { return nil, nil }

BLANK "whitespace" = [ \t\r\n]

_ "ignored" = (BLANK / Comment)*

EOL = [\n\r]

EOF = !.
