{
  package dsl

  func invalid(format string, tokens ...interface{}) error {
    return fmt.Errorf(format, tokens...)
  }

  // print arbitrary messages to STDERR; useful when making debug statements
  // for development
  func debug(format string, tokens ...interface{}) {
    fmt.Fprintf(os.Stderr, format + "\n", tokens...)
  }
}

Script = prog:Statement* EOF {
  return rootNode(c, prog)
}

Statement = statement:(EntityExpr / GenerateOverrideExpr / GenerateExpr) {
  return statement, nil
}

GenerateExpr = _ "generate" _ name:Identifier _ args:Arguments _ {
  return genNode(c, name, nil, args)
}

GenerateOverrideExpr = _ "generate" _ name:Identifier _ args:Arguments _ '{' _ body:FieldSet? _ '}' _ {
  return genNode(c, name, body, args)
}

EntityExpr "entity declaration" = _ "def" _ name:Identifier _ parent:EntityParent? _ '{' _ body:FieldSet? _ '}' _ {
	if parent == nil {
		return entityNode(c, name, body)
	} else {
	  return childEntityNode(c, name, body, parent)
  }
} / FailOnUnterminatedEntity

EntityParent "entity parent" = ':' _ parent:Identifier {
  return parent, nil
}

FieldSet "entity fields" = FailOnUndelimitedFields / first:FieldDecl rest:(_ ',' _ FieldDecl)* (_ ',')? {
  return delimitedNodeSlice(first, rest), nil
}

FieldDecl = StaticDecl / SymbolicDecl

StaticDecl "field declaration" = name:Identifier _ fieldValue:Literal _ {
  return staticFieldNode(c, name, fieldValue)
}

SymbolicDecl "field declaration" = name:Identifier _ fieldType:Builtin _ args:Arguments? _ {
  return dynamicFieldNode(c, name, fieldType, args)
}

Arguments = '(' _ body:ArgumentsBody? _ ')' {
  return defaultToEmptySlice(body), nil
} / FailOnUnterminatedArguments

ArgumentsBody "arguments body" = FailOnUndelimitedArgs / first:SingleArgument rest:(_ ',' _ SingleArgument)* {
  return delimitedNodeSlice(first, rest), nil
}

Literal = DateTimeLiteral / NumberLiteral / BoolLiteral / StringLiteral / NullLiteral

SingleArgument = Literal / Identifier

Identifier = !ReservedWord [a-z_]i[a-z0-9_]i* {
  return idNode(c)
} / FailOnIllegalIdentifier

Builtin "built-in types" = FieldTypes {
  return builtinNode(c)
}

DateTimeLiteral = date:IsoDate localTime:LocalTimePart? {
  return dateLiteralNode(c, date, localTime)
} / FailOnMissingDate

LocalTimePart = ts:TimePart zone:ZonePart? {
  if zone == nil {
    return []string{ts.(string)}, nil
  } else {
    return []string{ts.(string), zone.(string)}, nil
  }
}

IsoDate = DIGIT DIGIT DIGIT DIGIT '-' DIGIT DIGIT '-' DIGIT DIGIT { return string(c.text), nil}
TimePart = 'T'i DIGIT DIGIT ':' DIGIT DIGIT ':' DIGIT DIGIT { return strings.ToUpper(string(c.text)), nil }
ZonePart = 'Z'i { return "Z", nil } / [+-] DIGIT DIGIT ':'? DIGIT DIGIT { return strings.Replace(string(c.text), ":", "", -1), nil }

NumberLiteral = '-'? INT ('.' DIGIT+)? {
  if s := string(c.text); strings.ContainsAny(s, ".") {
    return floatLiteralNode(c, s)
  } else {
    return intLiteralNode(c, s)
  }
} / FailOnOctal

BoolLiteral = BoolToken {
  return boolLiteralNode(c)
}

NullLiteral = NullToken {
  return nullLiteralNode(c)
}

StringLiteral = '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
  return strLiteralNode(c)
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

UnicodeEscape = 'u' HEXDIG HEXDIG HEXDIG HEXDIG

INT = '0' / NON_ZERO DIGIT*

NON_ZERO = [1-9]

DIGIT = [0-9]

HEXDIG = [0-9a-f]i

ReservedWord = Keyword / FieldTypes / NullToken / BoolToken

Keyword = "def" / "generate"

FieldTypes = "integer" / "decimal" / "string" / "date" / "dict"

NullToken = "null"

BoolToken = "true" / "false"

/**
 *  88 88b 88 Yb    dP    db    88     88 8888b.      88""Yb 88   88 88     888888 .dP"Y8
 *  88 88Yb88  Yb  dP    dPYb   88     88  8I  Yb     88__dP 88   88 88     88__   `Ybo."
 *  88 88 Y88   YbdP    dP__Yb  88  .o 88  8I  dY     88"Yb  Y8   8P 88  .o 88""   o.`Y8b
 *  88 88  Y8    YP    dP""""Yb 88ood8 88 8888Y"      88  Yb `YbodP' 88ood8 888888 8bodP'
 */

FailOnOctal "octal numbers not supported" = "\\0" DIGIT+ { return Node{}, invalid("Octal sequences are not supported") }
FailOnUnterminatedEntity "unterminated entity" = _ "def" _ Identifier _ '{' _ FieldSet? _ EOF { return nil, invalid("Unterminated entity declaration (missing closing curly brace") }
FailOnUndelimitedFields "missing field delimiter" = FieldDecl (_ "," _) (_ "," _)+ {return nil, invalid("Expected another field declaration")} / FieldDecl (_ FieldDecl)+ { return nil, invalid("Multiple field declarations must be delimited with a comma") }
FailOnUnterminatedArguments "unterminated arguments" = '(' _ ArgumentsBody? _ (!SingleArgument [^)] / EOF) { return nil, invalid("Unterminated argument list (missing closing parenthesis)") }
FailOnUndelimitedArgs "missing argument delimiter" = SingleArgument ((_ / _ [^,})] _) SingleArgument)+ { return nil, invalid("Multiple arguments must be delimited with a comma") }
FailOnIllegalIdentifier "illegal identifier" = ReservedWord { return Node{Value: string(c.text)}, invalid("Illegal identifier: %q is a reserved word", string(c.text)) }
FailOnMissingDate "timestamps must have date" = LocalTimePart { return Node{}, invalid("Must include ISO-8601 (YYYY-MM-DD) date as part of timestamp") }

/**
 *  888888 88b 88 8888b.
 *  88__   88Yb88  8I  Yb
 *  88""   88 Y88  8I  dY
 *  888888 88  Y8 8888Y"
 */

_ "whitespace" = [ \t\r\n]*

EOF = !.
