{
  package dsl
}

Script = prog:Statement* EOF {
  return rootNode(c, prog)
}

Statement = statement:(EntityDef / EntityGen) {
  return statement, nil
}

EntityGen = _ "generate" _ name:Identifier _ args:Arguments _ {
  return genNode(c, name, args)
}

EntityDef = _ "def" _ name:Identifier _ '{' _ body:FieldSet? _ '}' _ {
  return entityNode(c, name, body)
}

FieldSet = first:FieldDecl rest:(_ ',' _ FieldDecl)* (_ ',')? {
  return delimitedNodeSlice(first, rest), nil
}

FieldDecl = StaticDecl / SymbolicDecl

StaticDecl = name:Identifier _ fieldValue:Literal _ {
  return staticFieldNode(c, name, fieldValue)
}

SymbolicDecl = name:Identifier _ fieldType:Builtin _ args:Arguments? _ {
  return dynamicFieldNode(c, name, fieldType, args)
}

Arguments = '(' _ first:SingleArgument rest:(_ ',' _ SingleArgument)* _ ')' {
  return delimitedNodeSlice(first, rest), nil
}

Literal = DateTimeLiteral / NumberLiteral / BoolLiteral / StringLiteral / NullLiteral

SingleArgument = Literal / Identifier

Identifier = !ReservedWord [a-z_]i[a-z0-9_]i* {
  return idNode(c)
}

Builtin "built-in types" = FieldTypes {
  return builtinNode(c)
}

DateTimeLiteral = date:(DIGIT DIGIT DIGIT DIGIT '-' DIGIT DIGIT '-' DIGIT DIGIT) localTime:LocalTimePart? {
  return dateLiteralNode(c, date, localTime)
}

LocalTimePart = ts:('T'i DIGIT DIGIT ':' DIGIT DIGIT ':' DIGIT DIGIT) zone:ZonePart? {
  ts = strings.ToUpper(charGroupAsString(ts))

  if zone == nil {
    return []string{ts.(string)}, nil
  } else {
    return []string {ts.(string), zone.(string)}, nil
  }
}

ZonePart = 'Z'i { return 'Z', nil } / [+-] DIGIT DIGIT ':'? DIGIT DIGIT { return strings.Replace(string(c.text), ":", "", -1), nil }

NumberLiteral = '-'? INT ('.' DIGIT+)? {
  if s := string(c.text); strings.ContainsAny(s, ".") {
    return floatLiteralNode(c, s)
  } else {
    return intLiteralNode(c, s)
  }
}

BoolLiteral = BoolToken {
  return boolLiteralNode(c)
}

NullLiteral = NullToken {
  return nullLiteralNode(c)
}

StringLiteral = '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
  return strLiteralNode(c)
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

UnicodeEscape = 'u' HEXDIG HEXDIG HEXDIG HEXDIG

INT = '0' / NON_ZERO DIGIT*

NON_ZERO = [1-9]

DIGIT = [0-9]

HEXDIG = [0-9a-f]i

ReservedWord = Keyword / FieldTypes / NullToken / BoolToken

Keyword = "def" / "generate"

FieldTypes = "integer" / "decimal" / "string" / "date" / "dict"

NullToken = "null"

BoolToken = "true" / "false"

_ "whitespace" = [ \t\r\n]*

EOF = !.
