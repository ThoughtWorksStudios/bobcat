{
  package dsl

  import "regexp"
  import u "github.com/ThoughtWorksStudios/bobcat/common"

  func invalid(format string, tokens ...interface{}) error {
    return fmt.Errorf(format, tokens...)
  }
}

Script = prog:(Statement / Comment)* EOF {
  u.Debug("rule Script")
  return rootNode(c, prog)
} / !Statement .* EOF { return nil, invalid("Don't know how to evaluate %q", string(c.text)) }

Statement = _ statement:(ImportStatement / Expr / Assignment) _ {
  u.Debug("rule Statement")
  return statement, nil
}

Value = Literal / Identifier

Expr = GenerateExpr / EntityExpr / Collection

ImportStatement = "import" _ path:StringLiteral {
  u.Debug("rule ImportStatement")
  pathNode, _ := path.(*Node)

  if fspath := strings.TrimSpace(pathNode.ValStr()); fspath == "" {
    return nil, invalid("import statement requires a resolvable path")
  } else {
    return importNode(c, fspath)
  }
} / FailOnBadImport

GenerateExpr = "generate" _ '(' _ count:Value _ ',' _ entity:EntityRef _ ')' {
  u.Debug("rule GenerateExpr")
  if count.(*Node).Kind != "literal-int" {
    return nil, invalid("`generate` takes a non-zero integer count as its first argument")
  }

  return genNode(c, entity, NodeSet{count.(*Node)})
} / FailOnUnterminatedGeneratorArguments / FailOnMissingGenerateArguments

Assignment = FailOnMissingRightHandAssignment / leftHand:Identifier _ ASSIGN_OP _ rightHand:Expr {
  if leftHand == nil {
    return nil, nil
  }

  u.Debug("rule Assignment left: %v to right: %v", leftHand, rightHand)
  return assignNode(c, leftHand, rightHand)
}

EntityRef = Assignment / EntityExpr / Identifier

EntityExpr "entity expression" = extends:Identifier? _ '{' _ body:FieldSet? _ '}' {
  u.Debug("rule EntityLiteral extends: %v, body: %v", extends, body)
  return entityNode(c, extends, body)
} / FailOnUnterminatedEntity

FieldSet "entity fields" = FailOnUndelimitedFields / first:FieldDecl rest:(_ ',' _ FieldDecl)* (_ ',')? {
  u.Debug("rule FieldSet first: %v, rest: %v", first, rest)
  if first == nil {
    return nil, nil
  }

  return delimitedNodeSlice(first, rest), nil
}

FieldDecl = StaticDecl / DynamicDecl / FailOnMissingFieldType

StaticDecl "field declaration" = name:Identifier _ fieldValue:Literal _ count:CountRange? _ {
  u.Debug("rule StaticDecl")
  if name == nil {
    return nil, nil
  }

  rng, _ := count.(*Node)
  return staticFieldNode(c, name, fieldValue, rng)
}

DynamicDecl "field declaration" = name:Identifier _ fieldType:(Builtin / EntityRef) _ args:Arguments? _ count:CountRange? _ {
  u.Debug("rule DynamicDecl name: %v => fieldType: %v with args %v", name, fieldType, args)
  if name == nil || fieldType == nil {
    return nil, nil
  }

  rng, _ := count.(*Node)
  return dynamicFieldNode(c, name, fieldType, args, rng)
}

CountRange = '<' _ countRange:(Range / NumberLiteral)? _ '>' { // TODO: accept Identifier
  u.Debug("rule CountRange")
  return countRange, nil
} / FailOnUnterminatedCountRange

Range = min:NumberLiteral ".." max:NumberLiteral {
  u.Debug("rule Range")
  return rangeNode(c, min, max)
}

Arguments = '(' _ body:ArgumentsBody? _ ')' {
  u.Debug("rule Arguments %v", body)
  return defaultToEmptySlice(body), nil
} / FailOnUnterminatedArguments

ArgumentsBody "arguments body" = FailOnUndelimitedArgs / first:Value rest:(_ ',' _ Value)* {
  u.Debug("rule ArgumentsBody")
  if first == nil {
    return nil, nil
  }

  return delimitedNodeSlice(first, rest), nil
}

Literal = Collection / DateTimeLiteral / NumberLiteral / BoolLiteral / StringLiteral / NullLiteral

Identifier = !ReservedWord [a-z0-9_$]i+ {
  val := string(c.text)
  u.Debug("rule Identifier => %q", val)

  if strings.Contains(val, "$") {
    return nil, invalid("Illegal identifier %q; identifiers start with a letter or underscore, followed by zero or more letters, underscores, and numbers", val)
  }

  if m, e := regexp.MatchString(`^\d`, val); m || e != nil {
    return nil, invalid("Illegal identifier %q; identifiers start with a letter or underscore, followed by zero or more letters, underscores, and numbers", val)
  }

  return idNode(c, val)
} / FailOnIllegalIdentifier

Builtin "built-in types" = FieldTypes {
  u.Debug("rule Builtin => %q", string(c.text))
  return builtinNode(c, string(c.text))
}

Collection = "[" _ body:ArgumentsBody? _ "]" {
  u.Debug("rule Collection")
  return collectionLiteralNode(c, body)
}

DateTimeLiteral = date:IsoDate localTime:LocalTimePart? {
  u.Debug("rule DateTimeLiteral")
  return dateLiteralNode(c, date, localTime)
} / FailOnMissingDate

LocalTimePart = ts:TimePart zone:ZonePart? {
  u.Debug("rule LocalTimePart")
  if zone == nil {
    return []string{ts.(string)}, nil
  } else {
    return []string{ts.(string), zone.(string)}, nil
  }
}

IsoDate = DIGIT DIGIT DIGIT DIGIT '-' DIGIT DIGIT '-' DIGIT DIGIT { return string(c.text), nil}
TimePart = 'T'i DIGIT DIGIT ':' DIGIT DIGIT ':' DIGIT DIGIT { return strings.ToUpper(string(c.text)), nil }
ZonePart = 'Z'i { return "Z", nil } / [+-] DIGIT DIGIT ':'? DIGIT DIGIT { return strings.Replace(string(c.text), ":", "", -1), nil }

NumberLiteral = '-'? INT ('.' DIGIT+)? {
  u.Debug("rule NumberLiteral")
  if s := string(c.text); strings.ContainsAny(s, ".") {
    return floatLiteralNode(c, s)
  } else {
    return intLiteralNode(c, s)
  }
} / FailOnOctal

BoolLiteral = BoolToken {
  u.Debug("rule BoolLiteral")
  return boolLiteralNode(c, string(c.text))
}

NullLiteral = NullToken {
  u.Debug("rule NullLiteral")
  return nullLiteralNode(c)
}

StringLiteral = '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
  u.Debug("rule StringLiteral")
  return strLiteralNode(c, string(c.text))
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

UnicodeEscape = 'u' HEXDIG HEXDIG HEXDIG HEXDIG

ASSIGN_OP = '='

INT = '0' / NON_ZERO DIGIT*

NON_ZERO = [1-9]

DIGIT = [0-9]

HEXDIG = [0-9a-f]i

ReservedWord = Keyword / FieldTypes / NullToken / BoolToken

Keyword = "import" / "generate"

FieldTypes = "integer" / "decimal" / "string" / "date" / "dict" / "bool" / "enum"

NullToken = "null"

BoolToken = "true" / "false"

/**
 *  88 88b 88 Yb    dP    db    88     88 8888b.      88""Yb 88   88 88     888888 .dP"Y8
 *  88 88Yb88  Yb  dP    dPYb   88     88  8I  Yb     88__dP 88   88 88     88__   `Ybo."
 *  88 88 Y88   YbdP    dP__Yb  88  .o 88  8I  dY     88"Yb  Y8   8P 88  .o 88""   o.`Y8b
 *  88 88  Y8    YP    dP""""Yb 88ood8 88 8888Y"      88  Yb `YbodP' 88ood8 888888 8bodP'
 */

FailOnBadImport "invalid import statment" = "import" _ [^ \t\r\n]* { return nil, invalid("import statement requires a path") }
FailOnOctal "octal numbers not supported" = "\\0" DIGIT+ { return Node{}, invalid("Octal sequences are not supported") }
FailOnUnterminatedEntity "unterminated entity" = _ Identifier? _ '{' _ FieldSet? _ EOF { return nil, invalid("Unterminated entity expression (missing closing curly brace") }
FailOnUndelimitedFields "missing field delimiter" = FieldDecl (_ "," _) (_ "," _)+ {return nil, invalid("Expected another field declaration")} / FieldDecl (_ FieldDecl)+ { return nil, invalid("Multiple field declarations must be delimited with a comma") }
FailOnUnterminatedCountRange "unterminated countRange" = '<' _ Range? _ ([^>] / EOF) { return nil, invalid("Unterminated countRange list (missing closing angled bracket)") }
FailOnUnterminatedArguments "unterminated arguments" = '(' _ ArgumentsBody? _ (!Value [^)] / EOF) { return nil, invalid("Unterminated argument list (missing closing parenthesis)") }
FailOnUndelimitedArgs "missing argument delimiter" = Value ((_ / _ [^,})] _) Value)+ { return nil, invalid("Multiple arguments must be delimited with a comma") }
FailOnIllegalIdentifier "illegal identifier" = ReservedWord {
  u.Debug("FailOnIllegalIdentifier => %q", string(c.text))
  return nil, invalid("Illegal identifier: %q is a reserved word", string(c.text))
}
FailOnMissingDate "timestamps must have date" = LocalTimePart { return Node{}, invalid("Must include ISO-8601 (YYYY-MM-DD) date as part of timestamp") }
FailOnMissingGenerateArguments = _ "generate" _ (EntityRef / '(' _ (EntityRef / Value) _ ')') _ { return nil, invalid("`generate` statement %q requires arguments `(count, entity)`", string(c.text)) }
FailOnUnterminatedGeneratorArguments = _ "generate" _ '(' _ ((EntityRef / Value) (_ ',' _ (EntityRef / Value))*)? _ [^)] _ { return nil, invalid("`generate` statement %q requires arguments `(count, entity)`", string(c.text)) }
FailOnMissingFieldType = Identifier { return nil, invalid("Missing field type for field declaration %q", string(c.text)) }
FailOnMissingRightHandAssignment = leftHand:Identifier _ ASSIGN_OP _ !Expr .* {
  u.Debug("rule FailOnMissingRightHandAssignment")
  if leftHand == nil {
    return nil, nil // bad identifier
  }
  return nil, invalid("Missing right-hand of assignment expression %q", string(c.text))
}

/**
 *  888888 88b 88 8888b.
 *  88__   88Yb88  8I  Yb
 *  88""   88 Y88  8I  dY
 *  888888 88  Y8 8888Y"
 */

Comment = '#' (!EOL .)* EOL { return nil, nil }

BLANK "whitespace" = [ \t\r\n]

_ "ignored" = (BLANK / Comment)*

EOL = [\n\r]

EOF = !.
