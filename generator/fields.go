package generator

import (
	. "github.com/ThoughtWorksStudios/bobcat/common"
	"github.com/ThoughtWorksStudios/bobcat/dictionary"
	"github.com/rs/xid"
	"math"
	"math/rand"
	"time"
)

var src = rand.NewSource(time.Now().UnixNano())

type Field struct {
	fieldType FieldType
	count     *CountRange
}

func (f *Field) Type() string {
	return f.fieldType.Type()
}

func (f *Field) GenerateValue() GeneratedValue {
	if !f.count.Multiple() {
		return f.fieldType.GenerateSingle()
	} else {
		count := f.count.Count()
		values := make([]interface{}, count)

		for i := 0; i < count; i++ {
			values[i] = f.fieldType.GenerateSingle()
		}

		return GenericGeneratedValue{Value: values}
	}
}

type FieldSet map[string]*Field

type FieldType interface {
	Type() string
	GenerateSingle() GeneratedValue
}

func NewField(fieldType FieldType, count *CountRange) *Field {
	return &Field{fieldType: fieldType, count: count}
}

type ReferenceType struct {
	referred  *Generator
	fieldName string
}

func (field *ReferenceType) Type() string {
	return "reference"
}

func (field *ReferenceType) GenerateSingle() GeneratedValue {
	ref := field.referred.fields[field.fieldName].fieldType
	return ref.GenerateSingle()
}

type EntityType struct {
	entityGenerator *Generator
}

func (field *EntityType) Type() string {
	return "entity"
}

func (field *EntityType) GenerateSingle() GeneratedValue {
	return GeneratedEntityValue{Value: field.entityGenerator.Generate(1)[0]}
}

type BoolType struct {
}

func (field *BoolType) Type() string {
	return "boolean"
}

func (field *BoolType) GenerateSingle() GeneratedValue {
	return GenericGeneratedValue{Value: (49 < rand.Intn(100))}
}

type MongoIDType struct {
}

func (field *MongoIDType) Type() string {
	return "mongoid"
}

func (field *MongoIDType) GenerateSingle() GeneratedValue {
	return GenericGeneratedValue{Value: xid.New()}
}

type LiteralType struct {
	value interface{}
}

func (field *LiteralType) Type() string {
	return "literal"
}

func (field *LiteralType) GenerateSingle() GeneratedValue {
	return GeneratedLiteralValue{Value: field.value}
}

type StringType struct {
	length int
}

func (field *StringType) Type() string {
	return "string"
}

const ALLOWED_CHARACTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@"

var LETTER_INDEX_BITS uint = uint(math.Ceil(math.Log2(float64(len(ALLOWED_CHARACTERS))))) // number of bits to represent ALLOWED_CHARACTERS
var LETTER_BIT_MASK int64 = 1<<LETTER_INDEX_BITS - 1                                      // All 1-bits, as many as LETTER_INDEX_BITS
var LETTERS_PER_INT63 uint = 63 / LETTER_INDEX_BITS                                       // # of letter indices fitting in 63 bits as generated by src.Int63

func (field *StringType) GenerateSingle() GeneratedValue {
	n := field.length
	b := make([]byte, n)

	for i, cache, remain := n-1, src.Int63(), LETTERS_PER_INT63; i >= 0; {
		if remain == 0 {
			cache, remain = src.Int63(), LETTERS_PER_INT63
		}
		if idx := int(cache & LETTER_BIT_MASK); idx < len(ALLOWED_CHARACTERS) {
			b[i] = ALLOWED_CHARACTERS[idx]
			i--
		}
		cache >>= LETTER_INDEX_BITS
		remain--
	}

	return GeneratedStringValue{Value: string(b)}
}

type IntegerType struct {
	min int
	max int
}

func (field *IntegerType) Type() string {
	return "integer"
}

func (field *IntegerType) GenerateSingle() GeneratedValue {
	result := float64(rand.Intn(int(field.max - field.min + 1)))
	result += float64(field.min)
	return GeneratedIntegerValue{Value: int64(result)}
}

type FloatType struct {
	min float64
	max float64
}

func (field *FloatType) Type() string {
	return "float"
}

func (field *FloatType) GenerateSingle() GeneratedValue {
	return GenericGeneratedValue{Value: rand.Float64()*(field.max-field.min) + field.min}
}

type DateType struct {
	min time.Time
	max time.Time
}

func (field *DateType) Type() string {
	return "date"
}

func (field *DateType) ValidBounds() bool {
	return field.min.Before(field.max)
}

func (field *DateType) GenerateSingle() GeneratedValue {
	min, max := field.min.Unix(), field.max.Unix()
	delta := max - min
	sec := rand.Int63n(delta) + min

	return GeneratedStringValue{Value: time.Unix(sec, 0).String()}
}

type DictType struct {
	category string
}

var CustomDictPath = ""

func (field *DictType) Type() string {
	return "dict"
}

func (field *DictType) GenerateSingle() GeneratedValue {
	dictionary.SetCustomDataLocation(CustomDictPath)
	return GeneratedStringValue{Value: dictionary.ValueFromDictionary(field.category)}
}

type EnumType struct {
	category string
	values   []interface{}
}

func (field *EnumType) Type() string {
	return "enum"
}

func (field *EnumType) GenerateSingle() GeneratedValue {
	return GenericGeneratedValue{Value: field.values[rand.Intn(len(field.values))]}
}
