{
  package main

  type node struct {
    kind     string
    name     string
    value    interface{}
    args     []node
    children []node
  }

  func toNodeSlice(v interface{}) []node {
    vars := v.([]interface{})
    nodes := make([]node, 0)
    for _, val := range vars {
      nodes = append(nodes, val.(node))
    }
      return nodes
  }

  func parseArgNodes(args interface{}) []node {
    if args == nil {
      return []node{}
    }
    return args.(node).value.([]node)
  }
}

Script "entire spec" = prog:Def* EOF {
  return node {
    kind: "root",
    children: toNodeSlice(prog),
  }, nil
}

Def "entity definition" = _ "def" _ entity:Identifier _ '{' body:FieldDecl* '}' _ {
  return node{
    kind: "entity",
    name: entity.(node).value.(string),
    children: toNodeSlice(body),
  }, nil
}

FieldDecl "field declaration" = _ name:Identifier _ kind:Type _ args:Args? _ ';' _ {
  return node {
    name: name.(node).value.(string),
    kind: "field",
    value: kind.(node).value.(string),
    args: parseArgNodes(args),
  }, nil
}

Args "arguments" = '(' _ args:(Range / Int / Identifier)* _ ')' {
  return node {
    kind: "args",
    value: toNodeSlice(args),
  }, nil
}

Range "numeric range" = min:Int _ ':' _ max:Int {
  minNode := node {
    kind: "min",
    value: min.(node).value.(int),
  }
  maxNode := node {
    kind: "max",
    value: max.(node).value.(int),
  }
  return node {
    kind: "range",
    args: []node{minNode, maxNode},
  }, nil
}

Identifier "variable name" = [a-zA-Z_][a-zA-Z0-9_]* {
  return node {
    kind: "variable",
    value: string(c.text),
  }, nil
}

Type "built-in types" = ("integer" / "decimal" / "string" / "date") {
  return node {
    kind: "type",
    value: string(c.text),
  }, nil
}

Int = [0-9]+ {
  i, _ := strconv.Atoi(string(c.text))
  return node {
    kind: "numeric",
    value: i,
  }, nil
}

_ "whitespace" = [ \t\r\n]*

EOF = !.
